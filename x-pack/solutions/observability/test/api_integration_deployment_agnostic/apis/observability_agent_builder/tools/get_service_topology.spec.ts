/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import expect from '@kbn/expect';
import { timerange } from '@kbn/synthtrace-client';
import {
  type ApmSynthtraceEsClient,
  API_GATEWAY_SERVICE,
  BATCH_WORKER_SERVICE,
  CHECKOUT_SERVICE,
  CYCLE_SERVICE_A,
  CYCLE_SERVICE_B,
  FRONTEND_SERVICE,
  generateCycleTopologyData,
  generateTopologyData,
  generateTraceIsolationData,
  KAFKA_CONSUMER_SERVICE,
  KAFKA_DEPENDENCY,
  PAYMENT_SERVICE,
  POSTGRES_DEPENDENCY,
  RECOMMENDATION_SERVICE,
  REDIS_DEPENDENCY,
  POSTGRES_DB,
  REDIS_DB,
} from '@kbn/synthtrace';
import type { OtherResult } from '@kbn/agent-builder-common';
import { OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID } from '@kbn/observability-agent-builder-plugin/server/tools';
import { uniq } from 'lodash';
import type { DeploymentAgnosticFtrProviderContext } from '../../../ftr_provider_context';
import { createAgentBuilderApiClient } from '../utils/agent_builder_client';

const START = 'now-15m';
const END = 'now';

/**
 * Topology generated by synthtrace (generateTopologyData):
 *
 *   frontend (nodejs)
 *     → checkout-service (java) [destination: "checkout-proxy:5050"]
 *         → postgres (db)
 *         → redis (cache)
 *         → kafka (messaging)
 *     → recommendation-service (python) [destination: "recommendation-lb:8080"]
 *         → postgres (db)
 *
 * IMPORTANT: span.destination.service.resource values intentionally differ from service.name
 * (e.g., "checkout-proxy:5050" instead of "checkout-service") to prevent heuristic matching.
 */
interface ServiceTopologyConnection {
  source: { 'service.name': string };
  target:
    | { 'service.name': string }
    | {
        'span.destination.service.resource': string;
        'span.type': string;
        'span.subtype': string;
      };
  metrics: {
    errorRate: number | null;
    latencyMs: number | null;
    throughputPerMin: number | null;
  } | null;
}

interface GetServiceTopologyToolResult extends OtherResult {
  data: {
    connections: ServiceTopologyConnection[];
  };
}

const getTargetName = (c: ServiceTopologyConnection) =>
  'service.name' in c.target
    ? c.target['service.name']
    : c.target['span.destination.service.resource'];

const getSourceName = (c: ServiceTopologyConnection) => c.source['service.name'];

const getConnectionByTarget = (connections: ServiceTopologyConnection[], targetName: string) =>
  connections.find((c) => getTargetName(c) === targetName);

export default function ({ getService }: DeploymentAgnosticFtrProviderContext) {
  const roleScopedSupertest = getService('roleScopedSupertest');
  const synthtrace = getService('synthtrace');

  describe(`tool: ${OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID}`, function () {
    let agentBuilderApiClient: ReturnType<typeof createAgentBuilderApiClient>;
    let apmSynthtraceEsClient: ApmSynthtraceEsClient;

    before(async () => {
      const scoped = await roleScopedSupertest.getSupertestWithRoleScope('editor');
      agentBuilderApiClient = createAgentBuilderApiClient(scoped);

      apmSynthtraceEsClient = await synthtrace.createApmSynthtraceEsClient();
      await apmSynthtraceEsClient.clean();

      const { client, generator } = generateTopologyData({
        range: timerange(START, END),
        apmEsClient: apmSynthtraceEsClient,
      });

      await client.index(generator);
    });

    after(async () => {
      await apmSynthtraceEsClient.clean();
    });

    const executeTopology = async (params: {
      serviceName: string;
      direction?: 'downstream' | 'upstream' | 'both';
      depth?: number;
    }) => {
      const results = await agentBuilderApiClient.executeTool<GetServiceTopologyToolResult>({
        id: OBSERVABILITY_GET_SERVICE_TOPOLOGY_TOOL_ID,
        params: { start: START, end: END, ...params },
      });
      return results[0].data.connections;
    };

    describe('downstream from frontend', () => {
      it('returns checkout-service and recommendation-service as targets', async () => {
        const connections = await executeTopology({
          serviceName: FRONTEND_SERVICE.serviceName,
        });

        const targets = connections.map(getTargetName);

        expect(targets).to.contain(CHECKOUT_SERVICE.serviceName);
        expect(targets).to.contain(RECOMMENDATION_SERVICE.serviceName);
      });

      it('resolves service.name even when span.destination.service.resource differs', async () => {
        // The trace-based pipeline joins exit spans with entry transactions
        // via parent.id/span.id to resolve the downstream service.name
        // (e.g., "checkout-proxy:5050" → "checkout-service").
        const connections = await executeTopology({
          serviceName: FRONTEND_SERVICE.serviceName,
        });
        const immediateTargets = connections
          .filter((c) => getSourceName(c) === FRONTEND_SERVICE.serviceName)
          .map(getTargetName)
          .sort();

        // Resolved service names — not raw resource names like "checkout-proxy:5050"
        expect(immediateTargets).to.eql(
          [CHECKOUT_SERVICE.serviceName, RECOMMENDATION_SERVICE.serviceName].sort()
        );
      });

      it('depth=1 fast path resolves service.name for instrumented services', async () => {
        // The depth=1 downstream fast path queries pre-aggregated metrics
        // plus the destination map, which resolves span.destination.service.resource
        // to service.name for instrumented downstream services.
        const connections = await executeTopology({
          serviceName: FRONTEND_SERVICE.serviceName,
          direction: 'downstream',
          depth: 1,
        });
        const targets = connections.map(getTargetName).sort();

        expect(targets).to.eql(
          [CHECKOUT_SERVICE.serviceName, RECOMMENDATION_SERVICE.serviceName].sort()
        );
      });

      it('depth=1 fast path returns the same dependencies and metrics as trace-based', async () => {
        const [traceBasedConnections, metricsBasedConnections] = await Promise.all([
          executeTopology({ serviceName: FRONTEND_SERVICE.serviceName }),
          executeTopology({
            serviceName: FRONTEND_SERVICE.serviceName,
            direction: 'downstream',
            depth: 1,
          }),
        ]);

        // Filter trace-based to immediate deps only (source = frontend)
        const traceBasedImmediate = traceBasedConnections.filter(
          (c) => getSourceName(c) === FRONTEND_SERVICE.serviceName
        );

        expect(traceBasedImmediate).to.eql(metricsBasedConnections);
        expect(metricsBasedConnections.map((c) => ({ source: c.source, target: c.target }))).to.eql(
          [
            {
              source: { 'service.name': FRONTEND_SERVICE.serviceName },
              target: { 'service.name': CHECKOUT_SERVICE.serviceName },
            },
            {
              source: { 'service.name': FRONTEND_SERVICE.serviceName },
              target: { 'service.name': RECOMMENDATION_SERVICE.serviceName },
            },
          ]
        );
      });
    });

    describe('downstream from checkout-service', () => {
      it('returns postgres, redis, kafka — but not siblings or parents', async () => {
        const connections = await executeTopology({
          serviceName: CHECKOUT_SERVICE.serviceName,
          direction: 'downstream',
        });
        const targets = connections.map(getTargetName);
        const sources = connections.map(getSourceName);

        // Direct dependencies
        expect(targets).to.contain(POSTGRES_DEPENDENCY.resource);
        expect(targets).to.contain(REDIS_DEPENDENCY.resource);
        expect(targets).to.contain(KAFKA_DEPENDENCY.resource);

        // No sibling (recommendation-service) or parent (frontend) connections
        expect(sources).not.to.contain(RECOMMENDATION_SERVICE.serviceName);
        expect(sources).not.to.contain(FRONTEND_SERVICE.serviceName);
      });
    });

    describe('upstream from checkout-service', () => {
      it('returns frontend as caller', async () => {
        const connections = await executeTopology({
          serviceName: CHECKOUT_SERVICE.serviceName,
          direction: 'upstream',
        });
        const sources = connections.map(getSourceName);

        expect(sources).to.contain(FRONTEND_SERVICE.serviceName);
      });
    });

    describe('both directions from checkout-service', () => {
      it('returns frontend upstream and postgres downstream', async () => {
        const connections = await executeTopology({
          serviceName: CHECKOUT_SERVICE.serviceName,
          direction: 'both',
        });
        const sources = connections.map(getSourceName);
        const targets = connections.map(getTargetName);

        expect(sources).to.contain(FRONTEND_SERVICE.serviceName);
        expect(targets).to.contain(POSTGRES_DEPENDENCY.resource);
      });
    });

    describe('upstream from postgres (multi-hop + blast radius)', () => {
      it('includes direct callers, indirect callers, and excludes sibling deps', async () => {
        const connections = await executeTopology({
          serviceName: POSTGRES_DEPENDENCY.resource,
          direction: 'upstream',
        });
        const sources = connections.map(getSourceName);
        const targets = connections.map(getTargetName);

        // Direct callers of postgres
        expect(sources).to.contain(CHECKOUT_SERVICE.serviceName);
        expect(sources).to.contain(RECOMMENDATION_SERVICE.serviceName);

        // Multi-hop: frontend → checkout-service is in the same trace
        expect(sources).to.contain(FRONTEND_SERVICE.serviceName);

        // Sibling deps (redis, kafka) should not appear
        expect(targets).not.to.contain(REDIS_DEPENDENCY.resource);
        expect(targets).not.to.contain(KAFKA_DEPENDENCY.resource);
      });
    });

    describe('RED metrics', () => {
      it('returns latency in ms, throughput, and error rate', async () => {
        const connections = await executeTopology({
          serviceName: CHECKOUT_SERVICE.serviceName,
          direction: 'downstream',
        });
        const { metrics } = getConnectionByTarget(connections, POSTGRES_DEPENDENCY.resource)!;

        expect(metrics?.latencyMs).to.be.a('number');
        expect(metrics?.latencyMs).to.be.greaterThan(0);
        // Regression: must be ms not µs — synthtrace spans are 30-40ms
        expect(metrics?.latencyMs).to.be.lessThan(1000);
        expect(metrics?.throughputPerMin).to.be.greaterThan(0);
        expect(metrics?.errorRate).to.be(0);
      });
    });

    describe('depth=1 downstream from frontend (immediate deps only)', () => {
      it('returns direct dependencies but not their children', async () => {
        const connections = await executeTopology({
          serviceName: FRONTEND_SERVICE.serviceName,
          direction: 'downstream',
          depth: 1,
        });
        const sources = connections.map(getSourceName);
        const targets = connections.map(getTargetName);

        // Direct deps of frontend — depth=1 uses the metrics-based fast path
        // which resolves service.name via the destination map
        expect(targets).to.contain(CHECKOUT_SERVICE.serviceName);
        expect(targets).to.contain(RECOMMENDATION_SERVICE.serviceName);

        // All sources should be the root service only
        const uniqueSources = uniq(sources);
        expect(uniqueSources).to.eql([FRONTEND_SERVICE.serviceName]);

        // No grandchild deps (postgres, redis, kafka belong to checkout-service)
        expect(targets).not.to.contain(POSTGRES_DEPENDENCY.resource);
        expect(targets).not.to.contain(REDIS_DEPENDENCY.resource);
        expect(targets).not.to.contain(KAFKA_DEPENDENCY.resource);
      });
    });

    describe('depth=1 upstream from checkout-service (immediate callers only)', () => {
      it('returns direct callers but not their ancestors', async () => {
        const connections = await executeTopology({
          serviceName: CHECKOUT_SERVICE.serviceName,
          direction: 'upstream',
          depth: 1,
        });
        const sources = connections.map(getSourceName);

        // frontend is a direct caller
        expect(sources).to.contain(FRONTEND_SERVICE.serviceName);

        // Only one hop back — no ancestors beyond frontend
        expect(connections.length).to.be(1);
      });
    });

    describe('non-existent service', () => {
      it('returns empty connections', async () => {
        const connections = await executeTopology({
          serviceName: 'non-existent-service',
          direction: 'downstream',
        });

        expect(connections.length).to.be(0);
      });
    });

    describe('external dependency target fields', () => {
      it('includes span.type and span.subtype for external dependencies', async () => {
        const connections = await executeTopology({
          serviceName: CHECKOUT_SERVICE.serviceName,
          direction: 'downstream',
        });
        const toPostgres = connections.find(
          (c) =>
            'span.destination.service.resource' in c.target &&
            c.target['span.destination.service.resource'] === POSTGRES_DEPENDENCY.resource
        );

        expect(toPostgres).to.be.ok();
        // External nodes must include span.type and span.subtype for the LLM
        // to understand the dependency type (db, cache, messaging, etc.)
        expect(toPostgres!.target).to.have.property('span.type', POSTGRES_DEPENDENCY.spanType);
        expect(toPostgres!.target).to.have.property(
          'span.subtype',
          POSTGRES_DEPENDENCY.spanSubtype
        );
      });
    });

    describe('depth=1 upstream from postgres (immediate callers only)', () => {
      it('returns direct callers but not their ancestors', async () => {
        const connections = await executeTopology({
          serviceName: POSTGRES_DEPENDENCY.resource,
          direction: 'upstream',
          depth: 1,
        });
        const sources = connections.map(getSourceName);

        // Direct callers of postgres
        expect(sources).to.contain(CHECKOUT_SERVICE.serviceName);
        expect(sources).to.contain(RECOMMENDATION_SERVICE.serviceName);

        // frontend is 2 hops away — should NOT appear with depth=1
        expect(sources).not.to.contain(FRONTEND_SERVICE.serviceName);
      });
    });

    /**
     * Trace isolation: shared intermediate services across traces
     *
     * When two different traces share an instrumented intermediate service,
     * the tool should only return connections from the queried service's traces.
     *
     * Topology:
     *   Trace 1: api-gateway → payment-service → kafka-consumer → postgres
     *   Trace 2: batch-worker → kafka-consumer → redis
     *
     * kafka-consumer appears in both traces but with different downstream deps.
     * Querying api-gateway downstream should show kafka-consumer → postgres
     * but NOT kafka-consumer → redis (which belongs to batch-worker's trace).
     */
    describe('trace isolation: shared intermediate services across traces', () => {
      before(async () => {
        await apmSynthtraceEsClient.clean();

        const { client, generator } = generateTraceIsolationData({
          range: timerange(START, END),
          apmEsClient: apmSynthtraceEsClient,
        });

        await client.index(generator);
      });

      after(async () => {
        await apmSynthtraceEsClient.clean();
      });

      it('downstream from api-gateway does not include redis from batch-worker trace', async () => {
        const connections = await executeTopology({
          serviceName: API_GATEWAY_SERVICE.serviceName,
          direction: 'downstream',
        });
        const targets = connections.map(getTargetName);

        expect(targets).to.contain(PAYMENT_SERVICE.serviceName);
        expect(targets).to.contain(KAFKA_CONSUMER_SERVICE.serviceName);
        expect(targets).to.contain(POSTGRES_DB.resource);
        expect(targets).not.to.contain(REDIS_DB.resource);
      });

      it('downstream from batch-worker does not include postgres from api-gateway trace', async () => {
        const connections = await executeTopology({
          serviceName: BATCH_WORKER_SERVICE.serviceName,
          direction: 'downstream',
        });
        const targets = connections.map(getTargetName);

        expect(targets).to.contain(KAFKA_CONSUMER_SERVICE.serviceName);
        expect(targets).to.contain(REDIS_DB.resource);
        expect(targets).not.to.contain(POSTGRES_DB.resource);
      });
    });

    /**
     * Cycle detection: A → B → A (callback pattern)
     *
     * When a service graph contains a cycle (service-b calls back to service-a),
     * the BFS traversal must terminate without infinite looping.
     *
     * Topology:
     *   cycle-service-a → cycle-service-b → cycle-service-a (callback)
     */
    describe('cycle: service-a → service-b → service-a (callback pattern)', () => {
      before(async () => {
        await apmSynthtraceEsClient.clean();

        const { client, generator } = generateCycleTopologyData({
          range: timerange(START, END),
          apmEsClient: apmSynthtraceEsClient,
        });

        await client.index(generator);
      });

      after(async () => {
        await apmSynthtraceEsClient.clean();
      });

      it('downstream traversal terminates and returns both directions', async () => {
        const connections = await executeTopology({
          serviceName: CYCLE_SERVICE_A.serviceName,
          direction: 'downstream',
        });
        const sources = connections.map(getSourceName);
        const targets = connections.map(getTargetName);

        // A→B edge
        expect(sources).to.contain(CYCLE_SERVICE_A.serviceName);
        expect(targets).to.contain(CYCLE_SERVICE_B.serviceName);

        // B→A callback edge
        expect(sources).to.contain(CYCLE_SERVICE_B.serviceName);
        expect(targets).to.contain(CYCLE_SERVICE_A.serviceName);

        // Exactly 2 connections — no duplicates from infinite traversal
        expect(connections.length).to.be(2);
      });
    });
  });
}
