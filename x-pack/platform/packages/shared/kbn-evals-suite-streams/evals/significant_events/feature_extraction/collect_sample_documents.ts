/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import type { Client } from '@elastic/elasticsearch';
import type { FieldValue } from '@elastic/elasticsearch/lib/api/types';
import type { ToolingLog } from '@kbn/tooling-log';
import type { FeatureExtractionScenario } from '../datasets';

const SAMPLE_DOCS_TARGET_UNIQUE_APPS = 8;
const SAMPLE_DOCS_MAX = 150;
const SAMPLE_DOCS_PAGE_SIZE = 50;
const REQUIRED_APP_SAMPLE_SIZE = 10;

const getAppNameFromLogDoc = (doc: Record<string, unknown>): string | undefined => {
  const resource = doc.resource as Record<string, unknown> | undefined;
  const attributes = resource?.attributes as Record<string, unknown> | undefined;
  const app = attributes?.app;
  return typeof app === 'string' && app.length > 0 ? app : undefined;
};

const extractRequiredAppsFromCriteria = (scenario: FeatureExtractionScenario): string[] => {
  const apps = new Set<string>();

  for (const c of scenario.output.criteria) {
    if (typeof c === 'string') continue;
    const id = (c as { id?: unknown }).id;
    if (typeof id !== 'string') continue;

    if (id.startsWith('entity-')) {
      apps.add(id.slice('entity-'.length));
      continue;
    }

    if (id.startsWith('dep-')) {
      const parts = id.slice('dep-'.length).split('-').filter(Boolean);
      for (const p of parts) apps.add(p);
    }
  }

  return [...apps].filter(Boolean);
};

const docKey = (doc: Record<string, unknown>): string => {
  const ts = String(doc['@timestamp'] ?? '');
  const body = doc.body as Record<string, unknown> | undefined;
  const text = typeof body?.text === 'string' ? body.text : '';
  return `${ts}:${text.slice(0, 200)}`;
};

export const collectSampleDocuments = async ({
  esClient,
  scenario,
  log,
}: {
  esClient: Client;
  scenario: FeatureExtractionScenario;
  log: ToolingLog;
}): Promise<Array<Record<string, unknown>>> => {
  const query = scenario.input.log_query_filter ?? { match_all: {} };

  const docs: Array<Record<string, unknown>> = [];
  const uniqueApps = new Set<string>();
  const seen = new Set<string>();

  let searchAfter: FieldValue[] | undefined;

  while (docs.length < SAMPLE_DOCS_MAX && uniqueApps.size < SAMPLE_DOCS_TARGET_UNIQUE_APPS) {
    const searchResult = await esClient.search<Record<string, unknown>>({
      index: 'logs*',
      size: SAMPLE_DOCS_PAGE_SIZE,
      query,
      sort: [{ '@timestamp': { order: 'desc' } }, { _shard_doc: { order: 'desc' } }],
      ...(searchAfter ? { search_after: searchAfter } : {}),
    });

    const hits = searchResult.hits.hits;
    if (hits.length === 0) {
      break;
    }

    for (const hit of hits) {
      const source = hit._source;
      if (!source) continue;
      const key = docKey(source);
      if (seen.has(key)) continue;
      seen.add(key);
      docs.push(source);
      const app = getAppNameFromLogDoc(source);
      if (app) uniqueApps.add(app);
      if (docs.length >= SAMPLE_DOCS_MAX) break;
    }

    searchAfter = hits.at(-1)?.sort as FieldValue[] | undefined;
    if (!searchAfter) {
      break;
    }
  }

  const requiredApps = extractRequiredAppsFromCriteria(scenario);
  const missingRequiredApps = requiredApps.filter((app) => !uniqueApps.has(app));
  if (missingRequiredApps.length > 0 && docs.length < SAMPLE_DOCS_MAX) {
    log.debug(`Missing required apps in sample: ${missingRequiredApps.join(', ')}`);
  }

  for (const app of missingRequiredApps) {
    if (docs.length >= SAMPLE_DOCS_MAX) break;

    const remaining = SAMPLE_DOCS_MAX - docs.length;
    const size = Math.min(REQUIRED_APP_SAMPLE_SIZE, remaining);

    const result = await esClient.search<Record<string, unknown>>({
      index: 'logs*',
      size,
      query: { term: { 'resource.attributes.app': app } },
      sort: [{ '@timestamp': { order: 'desc' } }, { _shard_doc: { order: 'desc' } }],
    });

    for (const hit of result.hits.hits) {
      const source = hit._source;
      if (!source) continue;
      const key = docKey(source);
      if (seen.has(key)) continue;
      seen.add(key);
      docs.push(source);
      const foundApp = getAppNameFromLogDoc(source);
      if (foundApp) uniqueApps.add(foundApp);
      if (docs.length >= SAMPLE_DOCS_MAX) break;
    }
  }

  log.info(
    `Collected ${docs.length} sample document(s) across ${uniqueApps.size} app(s): ${[
      ...uniqueApps,
    ].join(', ')}`
  );

  const stillMissing = requiredApps.filter((app) => !uniqueApps.has(app));
  if (stillMissing.length > 0) {
    log.warning(
      `Sample is missing required app(s) from criteria: ${stillMissing.join(
        ', '
      )} (criteria may not be satisfiable from available logs)`
    );
  }

  return docs;
};
