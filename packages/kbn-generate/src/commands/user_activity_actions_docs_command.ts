/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the "Elastic License
 * 2.0", the "GNU Affero General Public License v3.0 only", and the "Server Side
 * Public License v 1"; you may not use this file except in compliance with, at
 * your election, the "Elastic License 2.0", the "GNU Affero General Public
 * License v3.0 only", or the "Server Side Public License, v 1".
 */

import Fsp from 'fs/promises';
import Path from 'path';

import { REPO_ROOT } from '@kbn/repo-info';

import type { GenerateCommand } from '../generate_command';

const ACTIONS_REGISTRY_FILE = Path.resolve(
  REPO_ROOT,
  'src/core/packages/user-activity/server/src/user_activity_actions.ts'
);

const SNIPPET_FILE = Path.resolve(
  REPO_ROOT,
  // Output file generated by this command (useful to inspect for expected format).
  'docs/reference/user-activity/_snippets/user-activity-actions-list.md'
);

interface UserActivityActionDefinition {
  readonly description: string;
  readonly ownerTeam: string;
  readonly groupName: string;
  readonly versionAddedAt: string;
}

interface RemovedUserActivityActionDefinition extends UserActivityActionDefinition {
  readonly versionRemovedAt: string;
}

interface ActionRow {
  readonly id: string;
  readonly definition: UserActivityActionDefinition;
  readonly versionRemovedAt?: string;
}

/**
 * Normalizes action descriptions so they render consistently in the docs table.
 */
const normalizeDescription = (description: string) => description.replace(/\s+/g, ' ').trim();

/**
 * Renders the `{applies_to}` metadata that gets appended to action ids in the docs.
 */
const formatAppliesTo = ({
  versionAddedAt,
  versionRemovedAt,
}: {
  versionAddedAt: string;
  versionRemovedAt?: string;
}) => {
  if (versionRemovedAt) {
    return `{applies_to}\`stack: ga ${versionAddedAt}, removed ${versionRemovedAt}\``;
  }
  // the feature was introduced in 9.4 so no need to mention that in the actions
  if (versionAddedAt === '9.4') {
    return '';
  }
  return `{applies_to}\`stack: ga ${versionAddedAt}+\``;
};

/**
 * Builds a flat list of rows from the active + removed registries.
 */
const buildActionRows = ({
  userActivityActions,
  removedUserActivityActions,
}: {
  userActivityActions: Record<string, UserActivityActionDefinition>;
  removedUserActivityActions: Record<string, RemovedUserActivityActionDefinition>;
}): ActionRow[] => {
  return [
    ...Object.entries(userActivityActions).map(([id, definition]) => ({
      id,
      definition,
    })),
    ...Object.entries(removedUserActivityActions).map(([id, definition]) => ({
      id,
      definition,
      versionRemovedAt: definition.versionRemovedAt,
    })),
  ];
};

/**
 * Groups rows by `groupName` and returns a stable, sorted list of groups:
 * - Group names and action ids are sorted alphabetically.
 */
const groupAndSortRows = (rows: readonly ActionRow[]) => {
  const rowsByGroup = rows.reduce((acc, row) => {
    const groupName = row.definition.groupName;
    const existing = acc.get(groupName);

    if (existing) {
      existing.push(row);
    } else {
      acc.set(groupName, [row]);
    }

    return acc;
  }, new Map<string, ActionRow[]>());

  return [...rowsByGroup.entries()]
    .map(([groupName, groupRows]) => ({
      groupName,
      rows: [...groupRows].sort((a, b) => a.id.localeCompare(b.id, 'en')),
    }))
    .sort((a, b) => a.groupName.localeCompare(b.groupName, 'en'));
};

/**
 * Renders the left column of the table (action id + applies_to metadata).
 */
const renderActionCell = (row: ActionRow): string => {
  const { versionAddedAt } = row.definition;
  const { versionRemovedAt } = row;

  return `\`${row.id}\` ${formatAppliesTo({ versionAddedAt, versionRemovedAt })}`;
};

/**
 * Renders a single action row as a markdown table row.
 */
const renderRow = (row: ActionRow): string => {
  const actionCell = renderActionCell(row);
  const description = normalizeDescription(row.definition.description);

  return `| ${actionCell} | ${description} |`;
};

/**
 * Renders a full markdown section for a group, including its table header.
 */
const renderGroupSection = ({
  groupName,
  rows,
}: {
  readonly groupName: string;
  readonly rows: readonly ActionRow[];
}) => {
  return [
    `### ${groupName}`,
    '',
    '| Action | Description |',
    '| --- | --- |',
    ...rows.map(renderRow),
  ].join('\n');
};

/**
 * Loads the action registries from the source file so we can generate docs from the same source of truth.
 */
async function loadActionRegistries(): Promise<{
  readonly userActivityActions: Record<string, UserActivityActionDefinition>;
  readonly removedUserActivityActions: Record<string, RemovedUserActivityActionDefinition>;
}> {
  const registryModule = (await import(ACTIONS_REGISTRY_FILE)) as {
    userActivityActions: Record<string, UserActivityActionDefinition>;
    removedUserActivityActions: Record<string, RemovedUserActivityActionDefinition>;
  };

  return {
    userActivityActions: registryModule.userActivityActions,
    removedUserActivityActions: registryModule.removedUserActivityActions,
  };
}

/**
 * Renders the docs snippet.
 */
function renderSnippet({
  userActivityActions,
  removedUserActivityActions,
}: {
  userActivityActions: Record<string, UserActivityActionDefinition>;
  removedUserActivityActions: Record<string, RemovedUserActivityActionDefinition>;
}) {
  const header = `<!-- To regenerate, run: node scripts/generate user-activity-actions-docs -->`;

  const rows = buildActionRows({ userActivityActions, removedUserActivityActions });
  const groups = groupAndSortRows(rows);

  const body = groups.length === 0 ? '' : groups.map(renderGroupSection).join('\n\n') + '\n';

  return header + '\n' + body;
}

export const UserActivityActionsDocsCommand: GenerateCommand = {
  name: 'user-activity-actions-docs',
  description: 'Generate user-activity actions docs snippet (markdown)',
  usage: 'node scripts/generate user-activity-actions-docs',
  async run({ log }) {
    const { userActivityActions, removedUserActivityActions } = await loadActionRegistries();

    const snippet = renderSnippet({ userActivityActions, removedUserActivityActions });

    await Fsp.mkdir(Path.dirname(SNIPPET_FILE), { recursive: true });
    await Fsp.writeFile(SNIPPET_FILE, snippet, 'utf8');

    log.success(`Wrote ${Path.relative(REPO_ROOT, SNIPPET_FILE)}`);
  },
};
